//Copyright (C) 2013 Potix Corporation. All Rights Reserved.
//History: Mon, Jan 14, 2013  4:56:56 PM
// Author: tomyeh

/**
 * The RSP compiler
 */
class Compiler {
  final String sourceName;
  final Document source;
  final OutputStream destination;
  final Encoding encoding;
  final bool verbose;
  //the closure's name, args
  String _name, _args, _desc;
  ContentType _contentType;
  String _pre = "  "; //used to indent

  Compiler(Document this.source, OutputStream this.destination, {
    String this.sourceName,
    Encoding this.encoding:Encoding.UTF_8,
    bool this.verbose: false});

  void compile() {
    destination.writeString("//Auto-generated by RSP Compiler\n");
    if (sourceName != null)
      destination.writeString("//Source: ${sourceName}\n");

    Node startAt = _init();
    if (startAt != null) {
      _write("\n/** $_desc */\nvoid $_name(HttpConnect connect");
      if (_args != null)
        _write(", {$_args}");
      _writeln(") { //${_ln(startAt)}");

      for (final node in source.nodes)
        if (startAt == null || startAt == node) {
          startAt = null;
          _do(node);
        }

      _writeln("}");
    }
  }

  Node _init() {
    Node startAt;
    bool pgFound = false;
    for (final node in source.nodes) {
      if (node is ProcessingInstruction) {
        ProcessingInstruction pi = node;
        if (pi.target == "page") {
          if (pgFound) {
            _warning("Only one page directive allowed", pi);
            continue;
          }
          pgFound = true;

          final attrs = MapUtil.parse(pi.data, backslash:false, defaultValue:"");
          for (final nm in attrs.keys) {
            switch (nm) {
              case "name":
                _name = attrs[nm];
                break;
              case "content-type":
                _contentType = new ContentType(attrs[nm]);
                break;
              case "args":
              case "arguments":
                _args = attrs[nm];
                if (_args.trim().isEmpty)
                  _args = null;
                break;
              case "description":
                _desc = attrs[nm];
                break;
              default:
                _warning("Unknow attribute, $nm", pi);
                break;
            }
          }
        } else if (startAt == null) {
          if (pi.target == "dart") {
            _doDart(pi);
          } else
            startAt = pi;
        }
      } else if (startAt == null) {
        if (node is Text) {
          if (!node.text.trim().isEmpty)
            startAt = node;
        } else if (node is! Comment) {
          startAt = node;
        }
      }
    }

    if (_name == null) {
      if (sourceName == null || sourceName.isEmpty)
        throw "${_loc(pi)}The name attribute required";
      final i = sourceName.lastIndexOf('/') + 1,
        j = sourceName.indexOf('.', i);
      _name = StringUtil.camelize(
        j >= 0 ? sourceName.substring(i, j): sourceName.substring(i));
    }

    if (_desc == null)
      _desc = "Template, $_name, for rendering the view.";

    if (_contentType == null && sourceName != null) {
      final i = sourceName.lastIndexOf('.');
      if (i >= 0) {
        final ct = contentTypes[sourceName.substring(i + 1)];
        if (ct != null)
          _contentType = new ContentType(ct);
      }
    }
    return startAt;
 }

  void _do(Node node) {
    if (node is Element) {
      _doElement(node);
    } else if (node is Text) {
      final text = node.text.trim();
//      if (!text.isEmpty)
//        _newText(node, text);
    } else if (node is DocumentType) {
    } else if (node is ProcessingInstruction) {
      _doPI(node);
    }
  }
  void _doElement(Element elem) {
  }
  void _doPI(ProcessingInstruction pi) {
  }
  void _doDart(ProcessingInstruction pi) {
    var ln = _ln(pi);
    _writeln(ln.isEmpty ? ln: "\n//$ln#");
    _writeln(pi.data);
  }

  //Utilities//
  String _requiredAttr(Element elem, String attr) {
    final val = elem.attributes[attr];
    if (val == null || val.isEmpty)
      throw "${_loc(elem)}The $attr attribute is required";
    return val;
  }
  void _checkAttrs(Element elem, Set<String> allowedAttrs) {
    for (final attr in elem.attributes.keys)
      if (!allowedAttrs.contains(attr))
        _warning("The $attr attribute not allowed in ${elem.tagName}", elem);
  }

  _indent() => _pre = "$_pre  ";
  _undent() => _pre = _pre.substring(0, _pre.length - 2);

  void _write(String str) {
    destination.writeString(str, encoding);
  }
  void _writeln([String str]) {
    if (str != null)
      _write(str);
    _write("\n");
  }
  String _toTagComment(String name, Map<String, String> attrs)  {
    final StringBuffer sb = new StringBuffer("<")..add(name);
    for (final attr in attrs.keys) {
      final val = attrs[attr].replaceAll("\n", "\\n");
      sb.add(' $attr="${val}"');
      if (sb.length > 40)
        return "${sb.toString().substring(0, 36).trim()}...>";
    }
    return "$sb>";
  }
  String _toComment(String text) {
    text = text.replaceAll("\n", "\\n");
    return text.length > 30 ? "${text.substring(0, 27)}...": text;
  }

  //Returns the source and line information about the give node
  String _loc(Node node) {
    final sb = new StringBuffer();
    if (sourceName != null)
      sb..add(sourceName)..add(':');
    final ln = _ln(node);
    if (!ln.isEmpty)
      sb..add(ln)..add(':');
    return sb.isEmpty ? '': (sb..add(' ')).toString();
  }
  //Returns the line information about the given node
  String _ln(Node node) {
    try {
      var ln = node.lineNumber;
      if (ln != null)
        return ln.toString();
    } catch (e) { //Browser's XML parser doesn't support lineNumber
    }
    return "";
  }
  ///show warning messages
  void _warning(String msg, [Node node]) {
    print("${_loc(node)}Warning: $msg");
  }
}
